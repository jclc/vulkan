// The autogenerated code is released under Public Domain.

// WARNING: This file has automatically been generated on Tue, 16 Oct 2018 02:42:19 EEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vma

/*
#cgo CFLAGS: -I.. -DVK_NO_PROTOTYPES
#include "../vulkan/vulkan.h"
#include "vk_mem_alloc.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocDeviceMemoryCallbacksMemory allocates memory for type C.VmaDeviceMemoryCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemoryCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceMemoryCallbacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceMemoryCallbacksValue = unsafe.Sizeof([1]C.VmaDeviceMemoryCallbacks{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceMemoryCallbacks) Ref() *C.VmaDeviceMemoryCallbacks {
	if x == nil {
		return nil
	}
	return x.refd4225bbd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceMemoryCallbacks) Free() {
	if x != nil && x.allocsd4225bbd != nil {
		x.allocsd4225bbd.(*cgoAllocMap).Free()
		x.refd4225bbd = nil
	}
}

// NewDeviceMemoryCallbacksRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceMemoryCallbacksRef(ref unsafe.Pointer) *DeviceMemoryCallbacks {
	if ref == nil {
		return nil
	}
	obj := new(DeviceMemoryCallbacks)
	obj.refd4225bbd = (*C.VmaDeviceMemoryCallbacks)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceMemoryCallbacks) PassRef() (*C.VmaDeviceMemoryCallbacks, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4225bbd != nil {
		return x.refd4225bbd, nil
	}
	memd4225bbd := allocDeviceMemoryCallbacksMemory(1)
	refd4225bbd := (*C.VmaDeviceMemoryCallbacks)(memd4225bbd)
	allocsd4225bbd := new(cgoAllocMap)
	allocsd4225bbd.Add(memd4225bbd)

	var cpfnAllocate_allocs *cgoAllocMap
	refd4225bbd.pfnAllocate, cpfnAllocate_allocs = x.pfnAllocate.PassValue()
	allocsd4225bbd.Borrow(cpfnAllocate_allocs)

	var cpfnFree_allocs *cgoAllocMap
	refd4225bbd.pfnFree, cpfnFree_allocs = x.pfnFree.PassValue()
	allocsd4225bbd.Borrow(cpfnFree_allocs)

	x.refd4225bbd = refd4225bbd
	x.allocsd4225bbd = allocsd4225bbd
	return refd4225bbd, allocsd4225bbd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceMemoryCallbacks) PassValue() (C.VmaDeviceMemoryCallbacks, *cgoAllocMap) {
	if x.refd4225bbd != nil {
		return *x.refd4225bbd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceMemoryCallbacks) Deref() {
	if x.refd4225bbd == nil {
		return
	}
	x.pfnAllocate = *NewRef(unsafe.Pointer(&x.refd4225bbd.pfnAllocate))
	x.pfnFree = *NewRef(unsafe.Pointer(&x.refd4225bbd.pfnFree))
}

// allocVulkanFunctionsMemory allocates memory for type C.VmaVulkanFunctions in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVulkanFunctionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVulkanFunctionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVulkanFunctionsValue = unsafe.Sizeof([1]C.VmaVulkanFunctions{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VulkanFunctions) Ref() *C.VmaVulkanFunctions {
	if x == nil {
		return nil
	}
	return x.ref7d3d37cb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VulkanFunctions) Free() {
	if x != nil && x.allocs7d3d37cb != nil {
		x.allocs7d3d37cb.(*cgoAllocMap).Free()
		x.ref7d3d37cb = nil
	}
}

// NewVulkanFunctionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVulkanFunctionsRef(ref unsafe.Pointer) *VulkanFunctions {
	if ref == nil {
		return nil
	}
	obj := new(VulkanFunctions)
	obj.ref7d3d37cb = (*C.VmaVulkanFunctions)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VulkanFunctions) PassRef() (*C.VmaVulkanFunctions, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7d3d37cb != nil {
		return x.ref7d3d37cb, nil
	}
	mem7d3d37cb := allocVulkanFunctionsMemory(1)
	ref7d3d37cb := (*C.VmaVulkanFunctions)(mem7d3d37cb)
	allocs7d3d37cb := new(cgoAllocMap)
	allocs7d3d37cb.Add(mem7d3d37cb)

	var cvkGetPhysicalDeviceProperties_allocs *cgoAllocMap
	ref7d3d37cb.vkGetPhysicalDeviceProperties, cvkGetPhysicalDeviceProperties_allocs = x.vkGetPhysicalDeviceProperties.PassValue()
	allocs7d3d37cb.Borrow(cvkGetPhysicalDeviceProperties_allocs)

	var cvkGetPhysicalDeviceMemoryProperties_allocs *cgoAllocMap
	ref7d3d37cb.vkGetPhysicalDeviceMemoryProperties, cvkGetPhysicalDeviceMemoryProperties_allocs = x.vkGetPhysicalDeviceMemoryProperties.PassValue()
	allocs7d3d37cb.Borrow(cvkGetPhysicalDeviceMemoryProperties_allocs)

	var cvkAllocateMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkAllocateMemory, cvkAllocateMemory_allocs = x.vkAllocateMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkAllocateMemory_allocs)

	var cvkFreeMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkFreeMemory, cvkFreeMemory_allocs = x.vkFreeMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkFreeMemory_allocs)

	var cvkMapMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkMapMemory, cvkMapMemory_allocs = x.vkMapMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkMapMemory_allocs)

	var cvkUnmapMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkUnmapMemory, cvkUnmapMemory_allocs = x.vkUnmapMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkUnmapMemory_allocs)

	var cvkFlushMappedMemoryRanges_allocs *cgoAllocMap
	ref7d3d37cb.vkFlushMappedMemoryRanges, cvkFlushMappedMemoryRanges_allocs = x.vkFlushMappedMemoryRanges.PassValue()
	allocs7d3d37cb.Borrow(cvkFlushMappedMemoryRanges_allocs)

	var cvkInvalidateMappedMemoryRanges_allocs *cgoAllocMap
	ref7d3d37cb.vkInvalidateMappedMemoryRanges, cvkInvalidateMappedMemoryRanges_allocs = x.vkInvalidateMappedMemoryRanges.PassValue()
	allocs7d3d37cb.Borrow(cvkInvalidateMappedMemoryRanges_allocs)

	var cvkBindBufferMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkBindBufferMemory, cvkBindBufferMemory_allocs = x.vkBindBufferMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkBindBufferMemory_allocs)

	var cvkBindImageMemory_allocs *cgoAllocMap
	ref7d3d37cb.vkBindImageMemory, cvkBindImageMemory_allocs = x.vkBindImageMemory.PassValue()
	allocs7d3d37cb.Borrow(cvkBindImageMemory_allocs)

	var cvkGetBufferMemoryRequirements_allocs *cgoAllocMap
	ref7d3d37cb.vkGetBufferMemoryRequirements, cvkGetBufferMemoryRequirements_allocs = x.vkGetBufferMemoryRequirements.PassValue()
	allocs7d3d37cb.Borrow(cvkGetBufferMemoryRequirements_allocs)

	var cvkGetImageMemoryRequirements_allocs *cgoAllocMap
	ref7d3d37cb.vkGetImageMemoryRequirements, cvkGetImageMemoryRequirements_allocs = x.vkGetImageMemoryRequirements.PassValue()
	allocs7d3d37cb.Borrow(cvkGetImageMemoryRequirements_allocs)

	var cvkCreateBuffer_allocs *cgoAllocMap
	ref7d3d37cb.vkCreateBuffer, cvkCreateBuffer_allocs = x.vkCreateBuffer.PassValue()
	allocs7d3d37cb.Borrow(cvkCreateBuffer_allocs)

	var cvkDestroyBuffer_allocs *cgoAllocMap
	ref7d3d37cb.vkDestroyBuffer, cvkDestroyBuffer_allocs = x.vkDestroyBuffer.PassValue()
	allocs7d3d37cb.Borrow(cvkDestroyBuffer_allocs)

	var cvkCreateImage_allocs *cgoAllocMap
	ref7d3d37cb.vkCreateImage, cvkCreateImage_allocs = x.vkCreateImage.PassValue()
	allocs7d3d37cb.Borrow(cvkCreateImage_allocs)

	var cvkDestroyImage_allocs *cgoAllocMap
	ref7d3d37cb.vkDestroyImage, cvkDestroyImage_allocs = x.vkDestroyImage.PassValue()
	allocs7d3d37cb.Borrow(cvkDestroyImage_allocs)

	var cvkGetBufferMemoryRequirements2KHR_allocs *cgoAllocMap
	ref7d3d37cb.vkGetBufferMemoryRequirements2KHR, cvkGetBufferMemoryRequirements2KHR_allocs = x.vkGetBufferMemoryRequirements2KHR.PassValue()
	allocs7d3d37cb.Borrow(cvkGetBufferMemoryRequirements2KHR_allocs)

	var cvkGetImageMemoryRequirements2KHR_allocs *cgoAllocMap
	ref7d3d37cb.vkGetImageMemoryRequirements2KHR, cvkGetImageMemoryRequirements2KHR_allocs = x.vkGetImageMemoryRequirements2KHR.PassValue()
	allocs7d3d37cb.Borrow(cvkGetImageMemoryRequirements2KHR_allocs)

	x.ref7d3d37cb = ref7d3d37cb
	x.allocs7d3d37cb = allocs7d3d37cb
	return ref7d3d37cb, allocs7d3d37cb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VulkanFunctions) PassValue() (C.VmaVulkanFunctions, *cgoAllocMap) {
	if x.ref7d3d37cb != nil {
		return *x.ref7d3d37cb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VulkanFunctions) Deref() {
	if x.ref7d3d37cb == nil {
		return
	}
	x.vkGetPhysicalDeviceProperties = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetPhysicalDeviceProperties))
	x.vkGetPhysicalDeviceMemoryProperties = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetPhysicalDeviceMemoryProperties))
	x.vkAllocateMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkAllocateMemory))
	x.vkFreeMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkFreeMemory))
	x.vkMapMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkMapMemory))
	x.vkUnmapMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkUnmapMemory))
	x.vkFlushMappedMemoryRanges = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkFlushMappedMemoryRanges))
	x.vkInvalidateMappedMemoryRanges = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkInvalidateMappedMemoryRanges))
	x.vkBindBufferMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkBindBufferMemory))
	x.vkBindImageMemory = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkBindImageMemory))
	x.vkGetBufferMemoryRequirements = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetBufferMemoryRequirements))
	x.vkGetImageMemoryRequirements = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetImageMemoryRequirements))
	x.vkCreateBuffer = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkCreateBuffer))
	x.vkDestroyBuffer = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkDestroyBuffer))
	x.vkCreateImage = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkCreateImage))
	x.vkDestroyImage = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkDestroyImage))
	x.vkGetBufferMemoryRequirements2KHR = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetBufferMemoryRequirements2KHR))
	x.vkGetImageMemoryRequirements2KHR = *NewRef(unsafe.Pointer(&x.ref7d3d37cb.vkGetImageMemoryRequirements2KHR))
}

// allocRecordSettingsMemory allocates memory for type C.VmaRecordSettings in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecordSettingsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecordSettingsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRecordSettingsValue = unsafe.Sizeof([1]C.VmaRecordSettings{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecordSettings) Ref() *C.VmaRecordSettings {
	if x == nil {
		return nil
	}
	return x.ref2c79c965
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecordSettings) Free() {
	if x != nil && x.allocs2c79c965 != nil {
		x.allocs2c79c965.(*cgoAllocMap).Free()
		x.ref2c79c965 = nil
	}
}

// NewRecordSettingsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecordSettingsRef(ref unsafe.Pointer) *RecordSettings {
	if ref == nil {
		return nil
	}
	obj := new(RecordSettings)
	obj.ref2c79c965 = (*C.VmaRecordSettings)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecordSettings) PassRef() (*C.VmaRecordSettings, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c79c965 != nil {
		return x.ref2c79c965, nil
	}
	mem2c79c965 := allocRecordSettingsMemory(1)
	ref2c79c965 := (*C.VmaRecordSettings)(mem2c79c965)
	allocs2c79c965 := new(cgoAllocMap)
	allocs2c79c965.Add(mem2c79c965)

	var cflags_allocs *cgoAllocMap
	ref2c79c965.flags, cflags_allocs = (C.VmaRecordFlags)(x.flags), cgoAllocsUnknown
	allocs2c79c965.Borrow(cflags_allocs)

	var cpFilePath_allocs *cgoAllocMap
	ref2c79c965.pFilePath, cpFilePath_allocs = unpackPCharString(x.pFilePath)
	allocs2c79c965.Borrow(cpFilePath_allocs)

	x.ref2c79c965 = ref2c79c965
	x.allocs2c79c965 = allocs2c79c965
	return ref2c79c965, allocs2c79c965

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecordSettings) PassValue() (C.VmaRecordSettings, *cgoAllocMap) {
	if x.ref2c79c965 != nil {
		return *x.ref2c79c965, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecordSettings) Deref() {
	if x.ref2c79c965 == nil {
		return
	}
	x.flags = (RecordFlags)(x.ref2c79c965.flags)
	x.pFilePath = packPCharString(x.ref2c79c965.pFilePath)
}

// allocAllocatorCreateInfoMemory allocates memory for type C.VmaAllocatorCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocatorCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocatorCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocatorCreateInfoValue = unsafe.Sizeof([1]C.VmaAllocatorCreateInfo{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSDeviceMemoryCallbacks transforms a sliced Go data structure into plain C format.
func unpackSDeviceMemoryCallbacks(x []DeviceMemoryCallbacks) (unpacked *C.VmaDeviceMemoryCallbacks, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VmaDeviceMemoryCallbacks) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceMemoryCallbacksMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VmaDeviceMemoryCallbacks)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VmaDeviceMemoryCallbacks)(h.Data)
	return
}

// unpackSVulkanFunctions transforms a sliced Go data structure into plain C format.
func unpackSVulkanFunctions(x []VulkanFunctions) (unpacked *C.VmaVulkanFunctions, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VmaVulkanFunctions) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVulkanFunctionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VmaVulkanFunctions)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VmaVulkanFunctions)(h.Data)
	return
}

// unpackSRecordSettings transforms a sliced Go data structure into plain C format.
func unpackSRecordSettings(x []RecordSettings) (unpacked *C.VmaRecordSettings, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VmaRecordSettings) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRecordSettingsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VmaRecordSettings)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VmaRecordSettings)(h.Data)
	return
}

// packSDeviceMemoryCallbacks reads sliced Go data structure out from plain C format.
func packSDeviceMemoryCallbacks(v []DeviceMemoryCallbacks, ptr0 *C.VmaDeviceMemoryCallbacks) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceMemoryCallbacksValue]C.VmaDeviceMemoryCallbacks)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceMemoryCallbacksRef(unsafe.Pointer(&ptr1))
	}
}

// packSVulkanFunctions reads sliced Go data structure out from plain C format.
func packSVulkanFunctions(v []VulkanFunctions, ptr0 *C.VmaVulkanFunctions) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVulkanFunctionsValue]C.VmaVulkanFunctions)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVulkanFunctionsRef(unsafe.Pointer(&ptr1))
	}
}

// packSRecordSettings reads sliced Go data structure out from plain C format.
func packSRecordSettings(v []RecordSettings, ptr0 *C.VmaRecordSettings) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRecordSettingsValue]C.VmaRecordSettings)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRecordSettingsRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AllocatorCreateInfo) Ref() *C.VmaAllocatorCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref59aca072
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AllocatorCreateInfo) Free() {
	if x != nil && x.allocs59aca072 != nil {
		x.allocs59aca072.(*cgoAllocMap).Free()
		x.ref59aca072 = nil
	}
}

// NewAllocatorCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAllocatorCreateInfoRef(ref unsafe.Pointer) *AllocatorCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(AllocatorCreateInfo)
	obj.ref59aca072 = (*C.VmaAllocatorCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AllocatorCreateInfo) PassRef() (*C.VmaAllocatorCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref59aca072 != nil {
		return x.ref59aca072, nil
	}
	mem59aca072 := allocAllocatorCreateInfoMemory(1)
	ref59aca072 := (*C.VmaAllocatorCreateInfo)(mem59aca072)
	allocs59aca072 := new(cgoAllocMap)
	allocs59aca072.Add(mem59aca072)

	var cflags_allocs *cgoAllocMap
	ref59aca072.flags, cflags_allocs = (C.VmaAllocatorCreateFlags)(x.flags), cgoAllocsUnknown
	allocs59aca072.Borrow(cflags_allocs)

	var cpreferredLargeHeapBlockSize_allocs *cgoAllocMap
	ref59aca072.preferredLargeHeapBlockSize, cpreferredLargeHeapBlockSize_allocs = (C.VkDeviceSize)(x.preferredLargeHeapBlockSize), cgoAllocsUnknown
	allocs59aca072.Borrow(cpreferredLargeHeapBlockSize_allocs)

	var cpDeviceMemoryCallbacks_allocs *cgoAllocMap
	ref59aca072.pDeviceMemoryCallbacks, cpDeviceMemoryCallbacks_allocs = unpackSDeviceMemoryCallbacks(x.pDeviceMemoryCallbacks)
	allocs59aca072.Borrow(cpDeviceMemoryCallbacks_allocs)

	var cframeInUseCount_allocs *cgoAllocMap
	ref59aca072.frameInUseCount, cframeInUseCount_allocs = (C.uint32_t)(x.frameInUseCount), cgoAllocsUnknown
	allocs59aca072.Borrow(cframeInUseCount_allocs)

	var cpHeapSizeLimit_allocs *cgoAllocMap
	ref59aca072.pHeapSizeLimit, cpHeapSizeLimit_allocs = (*C.VkDeviceSize)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.pHeapSizeLimit)).Data)), cgoAllocsUnknown
	allocs59aca072.Borrow(cpHeapSizeLimit_allocs)

	var cpVulkanFunctions_allocs *cgoAllocMap
	ref59aca072.pVulkanFunctions, cpVulkanFunctions_allocs = unpackSVulkanFunctions(x.pVulkanFunctions)
	allocs59aca072.Borrow(cpVulkanFunctions_allocs)

	var cpRecordSettings_allocs *cgoAllocMap
	ref59aca072.pRecordSettings, cpRecordSettings_allocs = unpackSRecordSettings(x.pRecordSettings)
	allocs59aca072.Borrow(cpRecordSettings_allocs)

	x.ref59aca072 = ref59aca072
	x.allocs59aca072 = allocs59aca072
	return ref59aca072, allocs59aca072

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AllocatorCreateInfo) PassValue() (C.VmaAllocatorCreateInfo, *cgoAllocMap) {
	if x.ref59aca072 != nil {
		return *x.ref59aca072, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AllocatorCreateInfo) Deref() {
	if x.ref59aca072 == nil {
		return
	}
	x.flags = (AllocatorCreateFlags)(x.ref59aca072.flags)
	x.preferredLargeHeapBlockSize = (uint)(x.ref59aca072.preferredLargeHeapBlockSize)
	packSDeviceMemoryCallbacks(x.pDeviceMemoryCallbacks, x.ref59aca072.pDeviceMemoryCallbacks)
	x.frameInUseCount = (uint32)(x.ref59aca072.frameInUseCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.pHeapSizeLimit))
	hxfc4425b.Data = unsafe.Pointer(x.ref59aca072.pHeapSizeLimit)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	packSVulkanFunctions(x.pVulkanFunctions, x.ref59aca072.pVulkanFunctions)
	packSRecordSettings(x.pRecordSettings, x.ref59aca072.pRecordSettings)
}

// allocStatInfoMemory allocates memory for type C.VmaStatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStatInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStatInfoValue = unsafe.Sizeof([1]C.VmaStatInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StatInfo) Ref() *C.VmaStatInfo {
	if x == nil {
		return nil
	}
	return x.refd2066734
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StatInfo) Free() {
	if x != nil && x.allocsd2066734 != nil {
		x.allocsd2066734.(*cgoAllocMap).Free()
		x.refd2066734 = nil
	}
}

// NewStatInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStatInfoRef(ref unsafe.Pointer) *StatInfo {
	if ref == nil {
		return nil
	}
	obj := new(StatInfo)
	obj.refd2066734 = (*C.VmaStatInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StatInfo) PassRef() (*C.VmaStatInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd2066734 != nil {
		return x.refd2066734, nil
	}
	memd2066734 := allocStatInfoMemory(1)
	refd2066734 := (*C.VmaStatInfo)(memd2066734)
	allocsd2066734 := new(cgoAllocMap)
	allocsd2066734.Add(memd2066734)

	var cblockCount_allocs *cgoAllocMap
	refd2066734.blockCount, cblockCount_allocs = (C.uint32_t)(x.blockCount), cgoAllocsUnknown
	allocsd2066734.Borrow(cblockCount_allocs)

	var callocationCount_allocs *cgoAllocMap
	refd2066734.allocationCount, callocationCount_allocs = (C.uint32_t)(x.allocationCount), cgoAllocsUnknown
	allocsd2066734.Borrow(callocationCount_allocs)

	var cunusedRangeCount_allocs *cgoAllocMap
	refd2066734.unusedRangeCount, cunusedRangeCount_allocs = (C.uint32_t)(x.unusedRangeCount), cgoAllocsUnknown
	allocsd2066734.Borrow(cunusedRangeCount_allocs)

	var cusedBytes_allocs *cgoAllocMap
	refd2066734.usedBytes, cusedBytes_allocs = (C.VkDeviceSize)(x.usedBytes), cgoAllocsUnknown
	allocsd2066734.Borrow(cusedBytes_allocs)

	var cunusedBytes_allocs *cgoAllocMap
	refd2066734.unusedBytes, cunusedBytes_allocs = (C.VkDeviceSize)(x.unusedBytes), cgoAllocsUnknown
	allocsd2066734.Borrow(cunusedBytes_allocs)

	var callocationSizeMin_allocs *cgoAllocMap
	refd2066734.allocationSizeMin, callocationSizeMin_allocs = (C.VkDeviceSize)(x.allocationSizeMin), cgoAllocsUnknown
	allocsd2066734.Borrow(callocationSizeMin_allocs)

	var callocationSizeAvg_allocs *cgoAllocMap
	refd2066734.allocationSizeAvg, callocationSizeAvg_allocs = (C.VkDeviceSize)(x.allocationSizeAvg), cgoAllocsUnknown
	allocsd2066734.Borrow(callocationSizeAvg_allocs)

	var callocationSizeMax_allocs *cgoAllocMap
	refd2066734.allocationSizeMax, callocationSizeMax_allocs = (C.VkDeviceSize)(x.allocationSizeMax), cgoAllocsUnknown
	allocsd2066734.Borrow(callocationSizeMax_allocs)

	var cunusedRangeSizeMin_allocs *cgoAllocMap
	refd2066734.unusedRangeSizeMin, cunusedRangeSizeMin_allocs = (C.VkDeviceSize)(x.unusedRangeSizeMin), cgoAllocsUnknown
	allocsd2066734.Borrow(cunusedRangeSizeMin_allocs)

	var cunusedRangeSizeAvg_allocs *cgoAllocMap
	refd2066734.unusedRangeSizeAvg, cunusedRangeSizeAvg_allocs = (C.VkDeviceSize)(x.unusedRangeSizeAvg), cgoAllocsUnknown
	allocsd2066734.Borrow(cunusedRangeSizeAvg_allocs)

	var cunusedRangeSizeMax_allocs *cgoAllocMap
	refd2066734.unusedRangeSizeMax, cunusedRangeSizeMax_allocs = (C.VkDeviceSize)(x.unusedRangeSizeMax), cgoAllocsUnknown
	allocsd2066734.Borrow(cunusedRangeSizeMax_allocs)

	x.refd2066734 = refd2066734
	x.allocsd2066734 = allocsd2066734
	return refd2066734, allocsd2066734

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StatInfo) PassValue() (C.VmaStatInfo, *cgoAllocMap) {
	if x.refd2066734 != nil {
		return *x.refd2066734, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StatInfo) Deref() {
	if x.refd2066734 == nil {
		return
	}
	x.blockCount = (uint32)(x.refd2066734.blockCount)
	x.allocationCount = (uint32)(x.refd2066734.allocationCount)
	x.unusedRangeCount = (uint32)(x.refd2066734.unusedRangeCount)
	x.usedBytes = (uint)(x.refd2066734.usedBytes)
	x.unusedBytes = (uint)(x.refd2066734.unusedBytes)
	x.allocationSizeMin = (uint)(x.refd2066734.allocationSizeMin)
	x.allocationSizeAvg = (uint)(x.refd2066734.allocationSizeAvg)
	x.allocationSizeMax = (uint)(x.refd2066734.allocationSizeMax)
	x.unusedRangeSizeMin = (uint)(x.refd2066734.unusedRangeSizeMin)
	x.unusedRangeSizeAvg = (uint)(x.refd2066734.unusedRangeSizeAvg)
	x.unusedRangeSizeMax = (uint)(x.refd2066734.unusedRangeSizeMax)
}

// allocStatsMemory allocates memory for type C.VmaStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStatsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStatsValue = unsafe.Sizeof([1]C.VmaStats{})

// allocA32StatInfoMemory allocates memory for type [32]C.VmaStatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32StatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32StatInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32StatInfoValue = unsafe.Sizeof([1][32]C.VmaStatInfo{})

// unpackA32StatInfo transforms a sliced Go data structure into plain C format.
func unpackA32StatInfo(x [32]StatInfo) (unpacked [32]C.VmaStatInfo, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.VmaStatInfo) {
		go allocs.Free()
	})

	mem0 := allocA32StatInfoMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VmaStatInfo)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[32]C.VmaStatInfo)(mem0)
	return
}

// allocA16StatInfoMemory allocates memory for type [16]C.VmaStatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16StatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16StatInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16StatInfoValue = unsafe.Sizeof([1][16]C.VmaStatInfo{})

// unpackA16StatInfo transforms a sliced Go data structure into plain C format.
func unpackA16StatInfo(x [16]StatInfo) (unpacked [16]C.VmaStatInfo, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[16]C.VmaStatInfo) {
		go allocs.Free()
	})

	mem0 := allocA16StatInfoMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VmaStatInfo)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.VmaStatInfo)(mem0)
	return
}

// packA32StatInfo reads sliced Go data structure out from plain C format.
func packA32StatInfo(v *[32]StatInfo, ptr0 *[32]C.VmaStatInfo) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewStatInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packA16StatInfo reads sliced Go data structure out from plain C format.
func packA16StatInfo(v *[16]StatInfo, ptr0 *[16]C.VmaStatInfo) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewStatInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Stats) Ref() *C.VmaStats {
	if x == nil {
		return nil
	}
	return x.ref8f066b41
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Stats) Free() {
	if x != nil && x.allocs8f066b41 != nil {
		x.allocs8f066b41.(*cgoAllocMap).Free()
		x.ref8f066b41 = nil
	}
}

// NewStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStatsRef(ref unsafe.Pointer) *Stats {
	if ref == nil {
		return nil
	}
	obj := new(Stats)
	obj.ref8f066b41 = (*C.VmaStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Stats) PassRef() (*C.VmaStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8f066b41 != nil {
		return x.ref8f066b41, nil
	}
	mem8f066b41 := allocStatsMemory(1)
	ref8f066b41 := (*C.VmaStats)(mem8f066b41)
	allocs8f066b41 := new(cgoAllocMap)
	allocs8f066b41.Add(mem8f066b41)

	var cmemoryType_allocs *cgoAllocMap
	ref8f066b41.memoryType, cmemoryType_allocs = unpackA32StatInfo(x.memoryType)
	allocs8f066b41.Borrow(cmemoryType_allocs)

	var cmemoryHeap_allocs *cgoAllocMap
	ref8f066b41.memoryHeap, cmemoryHeap_allocs = unpackA16StatInfo(x.memoryHeap)
	allocs8f066b41.Borrow(cmemoryHeap_allocs)

	var ctotal_allocs *cgoAllocMap
	ref8f066b41.total, ctotal_allocs = x.total.PassValue()
	allocs8f066b41.Borrow(ctotal_allocs)

	x.ref8f066b41 = ref8f066b41
	x.allocs8f066b41 = allocs8f066b41
	return ref8f066b41, allocs8f066b41

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Stats) PassValue() (C.VmaStats, *cgoAllocMap) {
	if x.ref8f066b41 != nil {
		return *x.ref8f066b41, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Stats) Deref() {
	if x.ref8f066b41 == nil {
		return
	}
	packA32StatInfo(&x.memoryType, (*[32]C.VmaStatInfo)(unsafe.Pointer(&x.ref8f066b41.memoryType)))
	packA16StatInfo(&x.memoryHeap, (*[16]C.VmaStatInfo)(unsafe.Pointer(&x.ref8f066b41.memoryHeap)))
	x.total = *NewStatInfoRef(unsafe.Pointer(&x.ref8f066b41.total))
}

// allocAllocationCreateInfoMemory allocates memory for type C.VmaAllocationCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocationCreateInfoValue = unsafe.Sizeof([1]C.VmaAllocationCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AllocationCreateInfo) Ref() *C.VmaAllocationCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref1eb4cb8b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AllocationCreateInfo) Free() {
	if x != nil && x.allocs1eb4cb8b != nil {
		x.allocs1eb4cb8b.(*cgoAllocMap).Free()
		x.ref1eb4cb8b = nil
	}
}

// NewAllocationCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAllocationCreateInfoRef(ref unsafe.Pointer) *AllocationCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(AllocationCreateInfo)
	obj.ref1eb4cb8b = (*C.VmaAllocationCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AllocationCreateInfo) PassRef() (*C.VmaAllocationCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb4cb8b != nil {
		return x.ref1eb4cb8b, nil
	}
	mem1eb4cb8b := allocAllocationCreateInfoMemory(1)
	ref1eb4cb8b := (*C.VmaAllocationCreateInfo)(mem1eb4cb8b)
	allocs1eb4cb8b := new(cgoAllocMap)
	allocs1eb4cb8b.Add(mem1eb4cb8b)

	var cflags_allocs *cgoAllocMap
	ref1eb4cb8b.flags, cflags_allocs = (C.VmaAllocationCreateFlags)(x.flags), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	ref1eb4cb8b.usage, cusage_allocs = (C.VmaMemoryUsage)(x.usage), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cusage_allocs)

	var crequiredFlags_allocs *cgoAllocMap
	ref1eb4cb8b.requiredFlags, crequiredFlags_allocs = (C.VkMemoryPropertyFlags)(x.requiredFlags), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(crequiredFlags_allocs)

	var cpreferredFlags_allocs *cgoAllocMap
	ref1eb4cb8b.preferredFlags, cpreferredFlags_allocs = (C.VkMemoryPropertyFlags)(x.preferredFlags), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cpreferredFlags_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref1eb4cb8b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.memoryTypeBits), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cmemoryTypeBits_allocs)

	var cpool_allocs *cgoAllocMap
	ref1eb4cb8b.pool, cpool_allocs = *(*C.VmaPool)(unsafe.Pointer(&x.pool)), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cpool_allocs)

	var cpUserData_allocs *cgoAllocMap
	ref1eb4cb8b.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.pUserData)), cgoAllocsUnknown
	allocs1eb4cb8b.Borrow(cpUserData_allocs)

	x.ref1eb4cb8b = ref1eb4cb8b
	x.allocs1eb4cb8b = allocs1eb4cb8b
	return ref1eb4cb8b, allocs1eb4cb8b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AllocationCreateInfo) PassValue() (C.VmaAllocationCreateInfo, *cgoAllocMap) {
	if x.ref1eb4cb8b != nil {
		return *x.ref1eb4cb8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AllocationCreateInfo) Deref() {
	if x.ref1eb4cb8b == nil {
		return
	}
	x.flags = (AllocationCreateFlags)(x.ref1eb4cb8b.flags)
	x.usage = (MemoryUsage)(x.ref1eb4cb8b.usage)
	x.requiredFlags = (uint32)(x.ref1eb4cb8b.requiredFlags)
	x.preferredFlags = (uint32)(x.ref1eb4cb8b.preferredFlags)
	x.memoryTypeBits = (uint32)(x.ref1eb4cb8b.memoryTypeBits)
	x.pool = *(*Pool)(unsafe.Pointer(&x.ref1eb4cb8b.pool))
	x.pUserData = (unsafe.Pointer)(unsafe.Pointer(x.ref1eb4cb8b.pUserData))
}

// allocPoolCreateInfoMemory allocates memory for type C.VmaPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPoolCreateInfoValue = unsafe.Sizeof([1]C.VmaPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PoolCreateInfo) Ref() *C.VmaPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref740e9078
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PoolCreateInfo) Free() {
	if x != nil && x.allocs740e9078 != nil {
		x.allocs740e9078.(*cgoAllocMap).Free()
		x.ref740e9078 = nil
	}
}

// NewPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPoolCreateInfoRef(ref unsafe.Pointer) *PoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PoolCreateInfo)
	obj.ref740e9078 = (*C.VmaPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PoolCreateInfo) PassRef() (*C.VmaPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref740e9078 != nil {
		return x.ref740e9078, nil
	}
	mem740e9078 := allocPoolCreateInfoMemory(1)
	ref740e9078 := (*C.VmaPoolCreateInfo)(mem740e9078)
	allocs740e9078 := new(cgoAllocMap)
	allocs740e9078.Add(mem740e9078)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref740e9078.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.memoryTypeIndex), cgoAllocsUnknown
	allocs740e9078.Borrow(cmemoryTypeIndex_allocs)

	var cflags_allocs *cgoAllocMap
	ref740e9078.flags, cflags_allocs = (C.VmaPoolCreateFlags)(x.flags), cgoAllocsUnknown
	allocs740e9078.Borrow(cflags_allocs)

	var cblockSize_allocs *cgoAllocMap
	ref740e9078.blockSize, cblockSize_allocs = (C.VkDeviceSize)(x.blockSize), cgoAllocsUnknown
	allocs740e9078.Borrow(cblockSize_allocs)

	var cminBlockCount_allocs *cgoAllocMap
	ref740e9078.minBlockCount, cminBlockCount_allocs = (C.size_t)(x.minBlockCount), cgoAllocsUnknown
	allocs740e9078.Borrow(cminBlockCount_allocs)

	var cmaxBlockCount_allocs *cgoAllocMap
	ref740e9078.maxBlockCount, cmaxBlockCount_allocs = (C.size_t)(x.maxBlockCount), cgoAllocsUnknown
	allocs740e9078.Borrow(cmaxBlockCount_allocs)

	var cframeInUseCount_allocs *cgoAllocMap
	ref740e9078.frameInUseCount, cframeInUseCount_allocs = (C.uint32_t)(x.frameInUseCount), cgoAllocsUnknown
	allocs740e9078.Borrow(cframeInUseCount_allocs)

	x.ref740e9078 = ref740e9078
	x.allocs740e9078 = allocs740e9078
	return ref740e9078, allocs740e9078

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PoolCreateInfo) PassValue() (C.VmaPoolCreateInfo, *cgoAllocMap) {
	if x.ref740e9078 != nil {
		return *x.ref740e9078, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PoolCreateInfo) Deref() {
	if x.ref740e9078 == nil {
		return
	}
	x.memoryTypeIndex = (uint32)(x.ref740e9078.memoryTypeIndex)
	x.flags = (PoolCreateFlags)(x.ref740e9078.flags)
	x.blockSize = (uint)(x.ref740e9078.blockSize)
	x.minBlockCount = (uint)(x.ref740e9078.minBlockCount)
	x.maxBlockCount = (uint)(x.ref740e9078.maxBlockCount)
	x.frameInUseCount = (uint32)(x.ref740e9078.frameInUseCount)
}

// allocPoolStatsMemory allocates memory for type C.VmaPoolStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPoolStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPoolStatsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPoolStatsValue = unsafe.Sizeof([1]C.VmaPoolStats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PoolStats) Ref() *C.VmaPoolStats {
	if x == nil {
		return nil
	}
	return x.ref2403320d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PoolStats) Free() {
	if x != nil && x.allocs2403320d != nil {
		x.allocs2403320d.(*cgoAllocMap).Free()
		x.ref2403320d = nil
	}
}

// NewPoolStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPoolStatsRef(ref unsafe.Pointer) *PoolStats {
	if ref == nil {
		return nil
	}
	obj := new(PoolStats)
	obj.ref2403320d = (*C.VmaPoolStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PoolStats) PassRef() (*C.VmaPoolStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2403320d != nil {
		return x.ref2403320d, nil
	}
	mem2403320d := allocPoolStatsMemory(1)
	ref2403320d := (*C.VmaPoolStats)(mem2403320d)
	allocs2403320d := new(cgoAllocMap)
	allocs2403320d.Add(mem2403320d)

	var csize_allocs *cgoAllocMap
	ref2403320d.size, csize_allocs = (C.VkDeviceSize)(x.size), cgoAllocsUnknown
	allocs2403320d.Borrow(csize_allocs)

	var cunusedSize_allocs *cgoAllocMap
	ref2403320d.unusedSize, cunusedSize_allocs = (C.VkDeviceSize)(x.unusedSize), cgoAllocsUnknown
	allocs2403320d.Borrow(cunusedSize_allocs)

	var callocationCount_allocs *cgoAllocMap
	ref2403320d.allocationCount, callocationCount_allocs = (C.size_t)(x.allocationCount), cgoAllocsUnknown
	allocs2403320d.Borrow(callocationCount_allocs)

	var cunusedRangeCount_allocs *cgoAllocMap
	ref2403320d.unusedRangeCount, cunusedRangeCount_allocs = (C.size_t)(x.unusedRangeCount), cgoAllocsUnknown
	allocs2403320d.Borrow(cunusedRangeCount_allocs)

	var cunusedRangeSizeMax_allocs *cgoAllocMap
	ref2403320d.unusedRangeSizeMax, cunusedRangeSizeMax_allocs = (C.VkDeviceSize)(x.unusedRangeSizeMax), cgoAllocsUnknown
	allocs2403320d.Borrow(cunusedRangeSizeMax_allocs)

	var cblockCount_allocs *cgoAllocMap
	ref2403320d.blockCount, cblockCount_allocs = (C.size_t)(x.blockCount), cgoAllocsUnknown
	allocs2403320d.Borrow(cblockCount_allocs)

	x.ref2403320d = ref2403320d
	x.allocs2403320d = allocs2403320d
	return ref2403320d, allocs2403320d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PoolStats) PassValue() (C.VmaPoolStats, *cgoAllocMap) {
	if x.ref2403320d != nil {
		return *x.ref2403320d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PoolStats) Deref() {
	if x.ref2403320d == nil {
		return
	}
	x.size = (uint)(x.ref2403320d.size)
	x.unusedSize = (uint)(x.ref2403320d.unusedSize)
	x.allocationCount = (uint)(x.ref2403320d.allocationCount)
	x.unusedRangeCount = (uint)(x.ref2403320d.unusedRangeCount)
	x.unusedRangeSizeMax = (uint)(x.ref2403320d.unusedRangeSizeMax)
	x.blockCount = (uint)(x.ref2403320d.blockCount)
}

// allocAllocationInfoMemory allocates memory for type C.VmaAllocationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocationInfoValue = unsafe.Sizeof([1]C.VmaAllocationInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AllocationInfo) Ref() *C.VmaAllocationInfo {
	if x == nil {
		return nil
	}
	return x.ref9b2a54a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AllocationInfo) Free() {
	if x != nil && x.allocs9b2a54a2 != nil {
		x.allocs9b2a54a2.(*cgoAllocMap).Free()
		x.ref9b2a54a2 = nil
	}
}

// NewAllocationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAllocationInfoRef(ref unsafe.Pointer) *AllocationInfo {
	if ref == nil {
		return nil
	}
	obj := new(AllocationInfo)
	obj.ref9b2a54a2 = (*C.VmaAllocationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AllocationInfo) PassRef() (*C.VmaAllocationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b2a54a2 != nil {
		return x.ref9b2a54a2, nil
	}
	mem9b2a54a2 := allocAllocationInfoMemory(1)
	ref9b2a54a2 := (*C.VmaAllocationInfo)(mem9b2a54a2)
	allocs9b2a54a2 := new(cgoAllocMap)
	allocs9b2a54a2.Add(mem9b2a54a2)

	var cmemoryType_allocs *cgoAllocMap
	ref9b2a54a2.memoryType, cmemoryType_allocs = (C.uint32_t)(x.memoryType), cgoAllocsUnknown
	allocs9b2a54a2.Borrow(cmemoryType_allocs)

	var coffset_allocs *cgoAllocMap
	ref9b2a54a2.offset, coffset_allocs = (C.VkDeviceSize)(x.offset), cgoAllocsUnknown
	allocs9b2a54a2.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref9b2a54a2.size, csize_allocs = (C.VkDeviceSize)(x.size), cgoAllocsUnknown
	allocs9b2a54a2.Borrow(csize_allocs)

	var cpMappedData_allocs *cgoAllocMap
	ref9b2a54a2.pMappedData, cpMappedData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.pMappedData)), cgoAllocsUnknown
	allocs9b2a54a2.Borrow(cpMappedData_allocs)

	var cpUserData_allocs *cgoAllocMap
	ref9b2a54a2.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.pUserData)), cgoAllocsUnknown
	allocs9b2a54a2.Borrow(cpUserData_allocs)

	x.ref9b2a54a2 = ref9b2a54a2
	x.allocs9b2a54a2 = allocs9b2a54a2
	return ref9b2a54a2, allocs9b2a54a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AllocationInfo) PassValue() (C.VmaAllocationInfo, *cgoAllocMap) {
	if x.ref9b2a54a2 != nil {
		return *x.ref9b2a54a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AllocationInfo) Deref() {
	if x.ref9b2a54a2 == nil {
		return
	}
	x.memoryType = (uint32)(x.ref9b2a54a2.memoryType)
	x.offset = (uint)(x.ref9b2a54a2.offset)
	x.size = (uint)(x.ref9b2a54a2.size)
	x.pMappedData = (unsafe.Pointer)(unsafe.Pointer(x.ref9b2a54a2.pMappedData))
	x.pUserData = (unsafe.Pointer)(unsafe.Pointer(x.ref9b2a54a2.pUserData))
}

// allocDefragmentationInfoMemory allocates memory for type C.VmaDefragmentationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDefragmentationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDefragmentationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDefragmentationInfoValue = unsafe.Sizeof([1]C.VmaDefragmentationInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DefragmentationInfo) Ref() *C.VmaDefragmentationInfo {
	if x == nil {
		return nil
	}
	return x.refed3425ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DefragmentationInfo) Free() {
	if x != nil && x.allocsed3425ad != nil {
		x.allocsed3425ad.(*cgoAllocMap).Free()
		x.refed3425ad = nil
	}
}

// NewDefragmentationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDefragmentationInfoRef(ref unsafe.Pointer) *DefragmentationInfo {
	if ref == nil {
		return nil
	}
	obj := new(DefragmentationInfo)
	obj.refed3425ad = (*C.VmaDefragmentationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DefragmentationInfo) PassRef() (*C.VmaDefragmentationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed3425ad != nil {
		return x.refed3425ad, nil
	}
	memed3425ad := allocDefragmentationInfoMemory(1)
	refed3425ad := (*C.VmaDefragmentationInfo)(memed3425ad)
	allocsed3425ad := new(cgoAllocMap)
	allocsed3425ad.Add(memed3425ad)

	var cmaxBytesToMove_allocs *cgoAllocMap
	refed3425ad.maxBytesToMove, cmaxBytesToMove_allocs = (C.VkDeviceSize)(x.maxBytesToMove), cgoAllocsUnknown
	allocsed3425ad.Borrow(cmaxBytesToMove_allocs)

	var cmaxAllocationsToMove_allocs *cgoAllocMap
	refed3425ad.maxAllocationsToMove, cmaxAllocationsToMove_allocs = (C.uint32_t)(x.maxAllocationsToMove), cgoAllocsUnknown
	allocsed3425ad.Borrow(cmaxAllocationsToMove_allocs)

	x.refed3425ad = refed3425ad
	x.allocsed3425ad = allocsed3425ad
	return refed3425ad, allocsed3425ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DefragmentationInfo) PassValue() (C.VmaDefragmentationInfo, *cgoAllocMap) {
	if x.refed3425ad != nil {
		return *x.refed3425ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DefragmentationInfo) Deref() {
	if x.refed3425ad == nil {
		return
	}
	x.maxBytesToMove = (uint)(x.refed3425ad.maxBytesToMove)
	x.maxAllocationsToMove = (uint32)(x.refed3425ad.maxAllocationsToMove)
}

// allocDefragmentationStatsMemory allocates memory for type C.VmaDefragmentationStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDefragmentationStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDefragmentationStatsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDefragmentationStatsValue = unsafe.Sizeof([1]C.VmaDefragmentationStats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DefragmentationStats) Ref() *C.VmaDefragmentationStats {
	if x == nil {
		return nil
	}
	return x.refa09c1bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DefragmentationStats) Free() {
	if x != nil && x.allocsa09c1bc != nil {
		x.allocsa09c1bc.(*cgoAllocMap).Free()
		x.refa09c1bc = nil
	}
}

// NewDefragmentationStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDefragmentationStatsRef(ref unsafe.Pointer) *DefragmentationStats {
	if ref == nil {
		return nil
	}
	obj := new(DefragmentationStats)
	obj.refa09c1bc = (*C.VmaDefragmentationStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DefragmentationStats) PassRef() (*C.VmaDefragmentationStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa09c1bc != nil {
		return x.refa09c1bc, nil
	}
	mema09c1bc := allocDefragmentationStatsMemory(1)
	refa09c1bc := (*C.VmaDefragmentationStats)(mema09c1bc)
	allocsa09c1bc := new(cgoAllocMap)
	allocsa09c1bc.Add(mema09c1bc)

	var cbytesMoved_allocs *cgoAllocMap
	refa09c1bc.bytesMoved, cbytesMoved_allocs = (C.VkDeviceSize)(x.bytesMoved), cgoAllocsUnknown
	allocsa09c1bc.Borrow(cbytesMoved_allocs)

	var cbytesFreed_allocs *cgoAllocMap
	refa09c1bc.bytesFreed, cbytesFreed_allocs = (C.VkDeviceSize)(x.bytesFreed), cgoAllocsUnknown
	allocsa09c1bc.Borrow(cbytesFreed_allocs)

	var callocationsMoved_allocs *cgoAllocMap
	refa09c1bc.allocationsMoved, callocationsMoved_allocs = (C.uint32_t)(x.allocationsMoved), cgoAllocsUnknown
	allocsa09c1bc.Borrow(callocationsMoved_allocs)

	var cdeviceMemoryBlocksFreed_allocs *cgoAllocMap
	refa09c1bc.deviceMemoryBlocksFreed, cdeviceMemoryBlocksFreed_allocs = (C.uint32_t)(x.deviceMemoryBlocksFreed), cgoAllocsUnknown
	allocsa09c1bc.Borrow(cdeviceMemoryBlocksFreed_allocs)

	x.refa09c1bc = refa09c1bc
	x.allocsa09c1bc = allocsa09c1bc
	return refa09c1bc, allocsa09c1bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DefragmentationStats) PassValue() (C.VmaDefragmentationStats, *cgoAllocMap) {
	if x.refa09c1bc != nil {
		return *x.refa09c1bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DefragmentationStats) Deref() {
	if x.refa09c1bc == nil {
		return
	}
	x.bytesMoved = (uint)(x.refa09c1bc.bytesMoved)
	x.bytesFreed = (uint)(x.refa09c1bc.bytesFreed)
	x.allocationsMoved = (uint32)(x.refa09c1bc.allocationsMoved)
	x.deviceMemoryBlocksFreed = (uint32)(x.refa09c1bc.deviceMemoryBlocksFreed)
}
